#' Gating wrapper based on flowClust::tmixFilter
#' 
#' It basically calls flowClust to fit K clusters and construct K \code{polygonGate} from them.
#' 
#' @param fr \code{flowFrame}
#' @param channels \code{character} vector of channel/marker names (must be of length 2)
#' @param K \code{integer} the number of clusters to fit
#' @param quantile \code{numeric} vector of length K, which specifies the size of each cluster.
#' @param trans \code{numeric} must be 0
#' @param ... other arguments passed to \code{tmixFilter}
#' @return a \code{filters} object that contains K \code{filters} constructed from K clusters generated by flowClust
#' @export
#' @examples 
#' \dontrun{
#' for(K in 2:4){
#'     gates <- tmix2DGate(fr = parent, channels = c("CD4", "CD8"), K = K, quantile = 0.9)  
#'     print(xyplot(`CD8`~`CD4`, parent, smooth = FALSE, xbin = 32, filter = gates, stats = TRUE, main = paste0("K = ", K)))
#' }
#' }
tmix2DGate <- function(fr, channels, K, quantile = 0.85, trans = 0, ...){
  if(length(channels)!=2)
    stop("2D gate must have two channels!")
  if(trans != 0)
    stop("trans must be 0!")
  tmix_filter <- tmixFilter(parameters = channels, K = K, trans = trans,...)
  tmix_results <- try(filter(fr, tmix_filter), silent = F)
    
  #construct polygon gates 
  gates <- mapply(1:K, quantile, FUN = function(k, q, filter){
        as(openCyto:::.getEllipseGate(filter = tmix_results
                , include = k,
                quantile = q
                ,trans = 0), "polygonGate")
      })
  filters(gates)
}