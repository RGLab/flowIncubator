#' get nodes from {graphGML} object
#' 
#' @param x \code{graphGML}
#' @param y \code{character} node index. When \code{missing}, return all the nodes
#' @param order \code{character} specifying the order of nodes. options are "default", "bfs", "dfs", "tsort"
#' @param only.names \code{logical} specifiying whether user wants to get the entire \code{nodeData} or just the name of the population node
#'   
#' @export 
setMethod("getNodes", signature = c("graphGML"),
          definition = function(x, y
                                  , order = c("default", "bfs", "dfs", "tsort")
                                  , only.names = TRUE) {
  
  if (missing(y)){
    res <- nodeData(x)
    order <- match.arg(order)
    if(order != "default"){
      nodeIds <- eval(substitute(f1(x),list(f1=as.symbol(order))))
      if(order == "dfs")
        nodeIds <- nodeIds$discovered
      res <- res[nodeIds]
    }
  }else
  {
    res <- nodeData(x, y)
  }
  if(only.names){
    res <- sapply(res,`[[`,"popName")
  }
  if(length(res) == 1 && class(res) == "list")
      res <- res[[1]]
   res
})

#' get children nodes
#'
#' @param obj \code{gatingTemplate}
#' @param y \code{character} parent node path  
#' @export 
#' @aliases getChildren,gatingTemplate,character-method
#' @examples 
#' \dontrun{
#' gt <- gatingTemplate(system.file("extdata/gating_template/tcell.csv",package = "openCyto"))
#' 
#' getNodes(gt, "/nonDebris")
#' getChildren(gt, "/nonDebris") 
#' }
#' @importClassesFrom methods character ANY data.frame environment list logical matrix missing numeric oldClass
setMethod("getChildren", signature = c("graphGML", "character"),
          definition = function(obj, y) {
  edges(obj, y)[[1]]
})

#' get parent nodes
#' 
#' @param obj \code{graphGML}
#' @param y \code{character} child node path
#' 
#' @export
#' @importFrom flowWorkspace getParent 
setMethod("getParent", signature = c("graphGML", "character"),
          definition = function(obj, y) {

   inEdges(y, obj)[[1]]
  
})

#' get gate from the node
#' 
#' @param obj \code{graphGML}
#' @param y \code{character} node path
#' @importFrom flowWorkspace getGate
#' @export 
setMethod("getGate", signature = c("graphGML", "character"),
          definition = function(obj, y) {

          nodeData(obj, y)[["gateInfo"]]
})


#' show method for graphGML
#' 
#' show method for graphGML
#' 
#' @param object \code{graphGML}
#' @export 
#' @importFrom methods show
setMethod("show", signature = c("graphGML"),
          definition = function(object) {
  cat("--- Gating hieararchy parsed from GatingML: ")
  
  cat("\n")
  cat("\twith ", length(object@nodes), " populations defined\n")
})


#' plot the population tree
#' @param x a graphNEL generated by constructTree function
#' @param y not used
#' @param label specifies what to be dispaled as node label. Can be either 'popName' (population name parsed from GateSets) or 'gateName'(the name of the actual gate associated with each node)
#' @export
#' @importFrom graph nodeData nodes<- nodeRenderInfo<-
#' @importFrom Rgraphviz renderGraph layoutGraph
setMethod("plot", signature = c(x = "graphGML", y = "missing"), definition = function(x, label = c("popName", "gateName")){
  label <- match.arg(label, c("popName", "gateName"))
  if(label == "popName")
    nodeLabel  <- sapply(nodeData(x), `[[`, "popName")
  else
    nodeLabel  <- sapply(nodeData(x), function(i)i[["gateInfo"]][["gateName"]])
  
  
  #annotate the node with tailor gate info
  nTailoredGate <- sapply(nodeData(x), function(i)length(i[["gateInfo"]][["tailored_gate"]]))
  
  nAttrs <- list()
  
  nAttrs$label <- nodeLabel
  
  nAttrs$lty <- sapply(nTailoredGate
                       ,function(i)
                       {
                         ifelse(i>0,"dotted","solid")
                       })
  
  nodeRenderInfo(x) <- nAttrs
  lay <- layoutGraph(x
                     ,attrs=list(graph=list(rankdir="LR",page=c(8.5,11))
                                 ,node=list(fixedsize=FALSE
                                            ,fontsize = 12
                                            ,shape="ellipse"
                                 )
                     )
  )
  renderGraph(lay)
  
})

#' Apply the gatingML graph to a GatingSet
#' It applies the gates to the GatingSet based on the population tree described in graphGML.
#' @param x graphGML
#' @param y GatingSet
#' @param ... other arguments
#' @importFrom openCyto gating
#' @export
setMethod("gating", signature = c("graphGML", "GatingSet"), function(x, y, ...){
  gating.graphGML(x, y, ...)
})

#' @importFrom RBGL tsort
gating.graphGML <- function(gt, gs, ...) {
  gt_nodes <- tsort(gt)[-1]#by the topological order
  for (node in gt_nodes) {
    browser()
    # get parent node to gate
#     gt_node_pop <- nodeData(gt, node)
#     parentNode <- inEdges(node, gt)[[1]]
#     parent <- nodeData(gt, parentNode)[["popName"]]
#     if(is.null(parent))parent <- "root"
#     
#     this_gate <- (gt, node)
#     
#     
#     parentInd <- match(parent, getNodes(y[[1]], showHidden = TRUE))
#     if (is.na(parentInd)) 
#       stop("parent node '", parent, "' not gated yet!")
#     
#     #preprocessing
#     pp_res <- NULL
#     #    browser()
#     if(class(this_ppm) == "ppMethod")
#       pp_res <- preprocessing(x = this_ppm, y, parent = parent, gtPop = gt_node_pop, gm = this_gate, ...)
#     #    browser()
#     # pass the pops and gate to gating routine
#     filterObj <- gating(x = this_gate, y, parent = parent, gtPop = gt_node_pop, pp_res = pp_res, ...)
#     # update fct
#     if (!is.null(env_fct) && !is.null(filterObj)) {
#       nodeData(env_fct$fct, node, "fList")[[1]] <- filterObj
#     }  
    
    
  } 
  
}

#' Extract compensation from graphGML object.
#' @param x graphGML
#' @return compensation object
#' @importFrom flowWorkspace getCompensationMatrices
#' @export
setMethod("getCompensationMatrices", signature = "graphGML", definition = function(x){
  comp <- x@graphData[["compensation"]][[1]]
  ##TODO: determine the comp based on compensation-ref
  param <- parameters(comp)
  param <- gsub("Comp_", "", param)
  colnames(comp@spillover) <- param
  comp
})

#' Extract transformations from graphGML object.
#' @param x graphGML
#' @return transformList object
#' @importFrom flowWorkspace getTransformations
#' @importFrom flowCore transformList eval parameters colnames
#' @export
setMethod("getTransformations", signature = c(x = "graphGML"), function(x){
  
  trans <- x@graphData[["transformations"]]
  #remove the generic one
  #   samples <- sampleNames(`_data`)
  #   for(tran in trans){
  #     
  #     chnl <- as.vector(parameters(tran@parameters))
  #     if(chnl!="any"){
  #       for(sn in samples){
  #         fr <- `_data`[[sn]]
  #         exprs(`_data`[[sn]])[,chnl] <- eval(tran)(fr)
  #       }
  #     }
  #     
  #   }
  #   `_data`
  #can't use transform method 
  #since Gml version of trans object does not follow the convention of the transformation function (input)
  #thus can't construct the valid transformList to be operated on
  chnl <- sapply(trans, function(tran)unname(parameters(tran@parameters)), USE.NAMES = F)
  #convert from transform object to function since transform has empty function in .Data slot
  #which is not suitable for transformList constructor
  trans <- sapply(trans, eval, USE.NAMES = F)
  ind <- chnl != "any"
  
  
  transformList(chnl[ind], trans[ind])  
  
})


